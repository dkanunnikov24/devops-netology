<h3>Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"</h3>

1)Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа. <br/>

<b>ОТВЕТ:</b> Это встроенная команда оболочки, которая работает внутри сессии терминала. Внутренней функцией логичнее менять указатель на текущую дерикторию.<br/>
<br/>
2)Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.
<br/><br/>
<b>ОТВЕТ:</b> grep <some string> <some file> -c если нужно просто узнать количество строк с совпадениями.<br/>
<br/>
	~$ cat tst_bash<br/>
	if [[ -d /tmp ]];<br/>
	sdgedwwqws<br/>
	234<br/>
<br/>
	~$ grep 234 tst_bash -c<br/>
	1<br/>
	~$ grep 234 tst_bash |wc -l<br/>
	1<br/><br/>

3)Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?<br/>
<br/>
<b>ОТВЕТ:</b> systemd<br/>
<br/>
~$ pstree -p<br/>
systemd(1)─┬─VBoxService(743)─┬─{VBoxService}(744)<br/>
           │                  ├─{VBoxService}(745)<br/>
           │                  ├─{VBoxService}(746)<br/>
<br/><br/>                             
4)Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?<br/>
<br/>
<b>ОТВЕТ:</b><br/>
<br/>
Смотрим номер своего терминала<br/>
<br/>
~$ tty<br/>
/dev/pts/0<br/>
<br/>
Находясь в /dev/pts/0<br/>
<br/>
cd qqq 2>/dev/pts/1<br/>
Тогда в /dev/pts/1 будет<br/>
-bash: cd: qqq: No such file or directory<br/>
<br/>
5) Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.<br/>
<b>ОТВЕТ:</b><br/>
Пример:<br/>
~$ ls /dev > list | grep -n 'loop*' list  | tee loop_list<br/>
28:loop0<br/>
29:loop1<br/>
30:loop2<br/>
31:loop3<br/>
32:loop4<br/>
33:loop5<br/>
34:loop6<br/>
35:loop7<br/>
36:loop-control<br/>
<br/>
6)Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?<br/>
<b>ОТВЕТ:</b><br/>
Находясь в /dev/pts/0<br/>
<br/>
~$ echo "Privet" > /dev/pts/1<br/>
Наблюдаем "Privet"<br/>
<br/>
7)Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?<br/>
<b>ОТВЕТ:</b><br/>
После выполнения команды bash 5>&1 будет создан новый дескритор 5, который будет связан со стандартным дескриптором вывода.<br/>
Теперь если я выполнить echo netology > /proc/$$/fd/5 то bash продублирует вывод команды echo на стандартное устройство вывода, а не только в файл.<br/>
<br/>
8)Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty?<br/>
 Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. <br/>
 Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.<br/>
 <br/>
<b>ОТВЕТ:</b><br/>
 $ ls -l /root 55>&2 2>&1 1>&55 |grep denied -c <br/>
1<br/>
<br/>
Где:<br/>

55>&2 - новый дескриптор перенаправили в stderr<br/>
2>&1 - stderr перенаправили в stdout <br/>
1>&55 - stdout - перенаправили в новый дескриптор<br/>
<br/><br/>
9)Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?<br/>
<br/>
<b>ОТВЕТ:</b><br/>
Выведет переменные окружения.<br/>
Можно также вывести с помощью export или env.<br/>
<br/>
10)Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, proc/<PID>/exe.<br/><br/>
<b>ОТВЕТ:</b><br/>
/proc/<PID>/cmdline<br/>
  Этот файл содержит полную командную строку запуска процесса, кроме тех процессов, что полностью ушли в своппинг, а также тех, что превратились в зомби. В этих двух случаях в файле ничего нет, то есть чтение этого файла вернет 0 символов. Аргументы командной строки в этом файле указаны как список строк, каждая из которых завешается нулевым символом, с добавочным нулевым байтом после последней строки.
/proc/<PID>/exe<br/>
  <br/>Под Linux 2.2 и 2.4 exe является символьной ссылкой, содержащей фактическое полное имя выполняемого файла. Символьная ссылка exe может использоваться обычным образом - при попытке открыть exe будет открыт исполняемый файл. Вы можете даже ввести /proc/[number]/exe чтобы запустить другую копию процесса такого же как и процесс с номером [число].
<br/>Под Linux 2.0 и в более ранних версиях exe является указателем на запущенный файл и является символьной ссылкой. Вызов readlink(2) на этот специальный файл exe под Linux 2.0 и более ранних версий возвращает строку формата:
<br/>
[устройство]:индексный_дескриптор<br/>
<br/>
Например, строка [0301]:1502 означает индексный дескриптор 1502 на устройстве со старшим номером устройства 03 (IDE, MFM и т. д.) и младшим номером устройства 01 (первый раздел на первом диске).
<br/>
Для того, чтобы найти этот файл, может быть использована команда find(1) с опцией -inum.
<br/><br/>
11)Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo<br/>
<br/>
<b>ОТВЕТ:</b> версию 4_2<br/>
<br/>
~$ grep sse /proc/cpuinfo<br/>
<br/>
<br/>flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 cx16
<br/>pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm abm invpcid_single pti fsgsbase avx2 invpcid md_clear flush_l1d
<br/>flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 cx16
<br/>pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm abm invpcid_single pti fsgsbase avx2 invpcid md_clear flush_l1d
<br/>
<br/><br/>12)При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:
<br/>
<br/>vagrant@netology1:~$ ssh localhost 'tty'
<br/>not a tty
<br/>Почитайте, почему так происходит, и как изменить поведение.
<br/>
<br/><b>ОТВЕТ:</b>
<br/>
<br/>При отправке команд по ssh псевдотерминал по умолчанию не создаётся, поэтомы мы получаем такую ошибку. Принудительно создать tty можно ключом -t, втаком случае команда создает tty и показывает его номер:
<br/>
<br/>~$ ssh -t localhost tty
<br/>vagrant@localhost's password:
<br/>/dev/pts/3
<br/>Connection to localhost closed.
<br/>
<br/>13) Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.
<br/><b>ОТВЕТ:</b>
<br/>
<br/>~$ reptyr -L 362
<br/>Opened a new pty: /dev/pts/1


14)sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

<b>ОТВЕТ:</b>
В случае с sudo tee которая делает вывод одновременно на стандартное устройство вывода+в файл перенаправления не требуется и команда сразу пишет в файл от имени суперпользователя.
